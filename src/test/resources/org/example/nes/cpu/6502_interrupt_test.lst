AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

---------------------------------------------------------- Symbol Table ----------------------------------------------------------

              Symbol   Value        Decimal

               break : $0010             16
           brk_count : $0202            514
            brk_trap : $07b7           1975
               carry : $0001              1
        code_segment : $0400           1024   *
             D_clear : $0000              0   *
            data_bss : $0204            516
        data_segment : $0200            512   *
             decmode : $0008              8
                 fai : $0034             52
                 fao : $0030             48
                  fc : $0001              1
                  fn : $0080            128
                 fnc : $0081            129
                 fnv : $00c0            192
                 fnz : $0082            130
                fnzc : $0083            131
                  fv : $0040             64
                 fvz : $0042             66
                  fz : $0002              2
                 fzc : $0003              3
             IRQ_bit : $0000              0   *
               I_clr : <macro>
               I_ddr : $0000              0   *
             I_drive : $0000              0   *
            I_filter : $007f            127   *
              I_port : $bffc          49148   *
               I_set : <macro>
               I_src : $0203            515
              intdis : $0004              4
               irq_a : $0000              0
           irq_count : $0201            513
               irq_f : $0002              2
            irq_trap : $076f           1903
               irq_x : $0001              1
    load_data_direct : $0001              1   *
               lst_a : $01ff            511
               lst_f : $01fe            510
               minus : $0080            128
                  m8 : $00ff            255
                 m8i : $00fb            251
             NMI_bit : $0001              1   *
               nmi_a : $0003              3
           nmi_count : $0200            512
               nmi_f : $0005              5
            nmi_trap : $0729           1833
               nmi_x : $0004              4
              overfl : $0040             64
           push_stat : <macro>
              report : $0000              0   *
              reserv : $0020             32
            res_trap : $076a           1898
            set_stat : <macro>
               start : $0400           1024
                 stp : <macro>
             success : <macro>
                trap : <macro>
             trap_eq : <macro>
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    2
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

             trap_ne : <macro>
                 wai : <macro>
                zero : $0002              2
           zero_page : $0000              0   *
                 zpt : $0000              0
              zp_bss : $0006              6
            __6502__ : $0001              1

55 labels used

1025 lines read, no errors in pass 1.
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    3
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

                        ;
                        ; 6 5 0 2   I N T E R R U P T   T E S T
                        ;
                        ; Copyright (C) 2013  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test IRQ and NMI of a 6502 emulator. It requires
                        ; an internal or external feedback register to the IRQ & NMI inputs
                        ; 
                        ; version 15-aug-2014
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 from http://www.kingswood-consulting.co.uk/assemblers/
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex and
                        ; enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   19-jul-2013  1st version distributed for testing
                        ;   16-aug-2013  added error report to standard output option
                        ;   15-aug-2014  added filter to feedback (bit 7 will cause diag stop in emu)
                        
                        
                        ; C O N F I G U R A T I O N
                        ;
                        ;ROM_vectors MUST be writable & the I_flag MUST be alterable
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0001 =                  load_data_direct = 1
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    4
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

                        
                        ;NMI & IRQ are tested with a feedback register
                        ;emulators diag register - set i_drive = 0 for a latch (74HC573)
bffc =                  I_port      = $bffc     ;feedback port address
0000 =                  I_ddr       = 0         ;feedback DDR address, 0 = no DDR
0000 =                  I_drive     = 0         ;0 = totem pole, 1 = open collector
0000 =                  IRQ_bit     = 0         ;bit number of feedback to IRQ
0001 =                  NMI_bit     = 1         ;bit number of feedback to NMI, -1 if not available
007f =                  I_filter    = $7f       ;filtering bit 7 = diag stop
                        
                        ;typical IO chip port B - set i_drive = 0 to avoid pullup resistors
                        ;I_port      = $bfb2     ;feedback port address
                        ;I_ddr       = $bfb3     ;feedback DDR address, 0 = no DDR
                        ;I_drive     = 1        ;0 = totem pole, 1 = open collector
                        ;IRQ_bit     = 0         ;bit number of feedback to IRQ
                        ;NMI_bit     = 1         ;bit number of feedback to NMI, -1 if not available
                        ;I_filter    = $ff       ;no bits filtered
                        
                        ;decimal mode flag during IRQ, NMI & BRK
0000 =                  D_clear     = 0         ;0 = not cleared (NMOS), 1 = cleared (CMOS)
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, 6 consecutive Bytes required
0000 =                  zero_page = $0
                        
                        ;data_segment memory start address, 4 consecutive Bytes required
0200 =                  data_segment = $200  
                        
                        ;code_segment memory start address
0400 =                  code_segment = $400
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel)
0000 =                  report = 0
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                                endm
                        trap_ne macro
                                bne *           ;failed not equal (non zero)
                                endm
                        ; please observe that during the test the stack gets invalidated
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    5
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to set status
                        push_stat   macro       ;setting flags in the processor status register
                                    lda #\1
                                    pha         ;use stack to load status
                                    endm
                        
                        set_stat    macro       ;setting flags in the processor status register
                                    lda #\1
                                    pha         ;use stack to load status
                                    plp
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    6
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
0000 =                          org zero_page
                        ;BRK, IRQ, NMI test interrupt save
0000 :                  zpt
0000 : 00               irq_a   ds  1               ;a register
0001 : 00               irq_x   ds  1               ;x register
0002 : 00               irq_f   ds  1               ;flags
0003 : 00               nmi_a   ds  1               ;a register
0004 : 00               nmi_x   ds  1               ;x register
0005 : 00               nmi_f   ds  1               ;flags
0006 :                  zp_bss
                        
                        ;fixed stack locations
01fe =                  lst_f   equ $1fe            ;last flags before interrupt
01ff =                  lst_a   equ $1ff            ;last accumulator before interrupt
                            
0200 =                          org data_segment
                        ;concurrent NMI, IRQ & BRK test result
0200 : 00               nmi_count   ds  1           ;lowest number handled first, $ff = never
0201 : 00               irq_count   ds  1           ;separation-1 = instructions between interrupts
0202 : 00               brk_count   ds  1
                        ;expected interrupt mask
0203 : 00               I_src       ds  1           ;bit: 0=BRK, 1=IRQ, 2=NMI
0204 :                  data_bss
                        
                                code
0400 =                          org code_segment
0400 : d8               start   cld
0401 : a900                     lda #0           ;clear expected interrupts for 2nd run
0403 : 8d0302                   sta I_src
0406 : a2ff                     ldx #$ff
0408 : 9a                       txs
                            
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                        
                        ; load system vectors
                            if load_data_direct != 1
                                ldx #5
                        ld_vect lda vec_init,x
                                sta vec_bss,x
                                dex
                                bpl ld_vect
                            endif
                        
                        ; IRQ & NMI test - requires a feedback register
                            if I_drive > 1
                                ERROR           ;invalid interrupt drive!
                            endif
                          if NMI_bit < 0
                            if I_drive = 0      ;totem pole (push/pull, 0 -> I_port to force interrupt)
                        I_set   macro  ibit     ;ibit = interrupt bit
                                lda I_port      ;turn on interrupt by bit
                                and #I_filter-(1<<\1)
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    7
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

                                plp             ;set flags
                                pha             ;save to verify
                                php
                                sta I_port      ;interrupt next instruction plus outbound delay
                                endm
                        I_clr   macro  ibit     ;ibit = interrupt bit
                                lda I_port      ;turn off interrupt by bit
                                and #I_filter
                                ora #(1<<ibit)
                                sta I_port
                                endm
                                I_clr   IRQ_bit ;turn off IRQ
                              if I_ddr != 0     ;with DDR
                                lda I_ddr       ;set DDR for IRQ to enabled
                                and #I_filter
                                ora #(1<<IRQ_bit)
                                sta I_ddr
                              endif    
                            else                ;open collector, 0 -> I_DDR or I_port to force interrupt
                              if I_ddr != 0     ;with DDR
                        I_set   macro  ibit     ;ibit = interrupt bit
                                lda I_ddr       ;turn on interrupt by bit
                                and #I_filter
                                ora #(1<<\1)
                                plp             ;set flags
                                pha             ;save to verify
                                php
                                sta I_ddr       ;interrupt next instruction plus outbound delay
                                endm
                        I_clr   macro  ibit     ;ibit = interrupt bit
                                lda I_ddr       ;turn off interrupt by bit
                                and #I_filter-(1<<ibit)
                                sta I_ddr 
                                endm
                                I_clr   IRQ_bit ;turn off IRQ
                                lda I_port      ;precharge IRQ
                                and #I_filter-(1<<IRQ_bit)
                                sta I_port
                              else              ;no DDR
                        I_set   macro  ibit     ;ibit = interrupt bit
                                lda I_port      ;turn on interrupt by bit
                                and #I_filter
                                ora #(1<<\1)
                                plp             ;set flags
                                pha             ;save to verify
                                php
                                sta I_port      ;interrupt next instruction plus outbound delay
                                endm
                        I_clr   macro  ibit     ;ibit = interrupt bit
                                lda I_port      ;turn off interrupt by bit
                                and #I_filter-(1<<ibit)
                                sta I_port
                                endm
                                I_clr   IRQ_bit ;turn off IRQ
                              endif
                            endif
                          else
                            if I_drive = 0      ;totem pole (push/pull, 0 -> I_port to force interrupt)
                        I_set   macro  ibit     ;ibit = interrupt bit
                                lda I_port      ;turn on interrupt by bit
                                if ibit > 7     ;set both NMI & IRQ
                                  and #I_filter-(1<<IRQ_bit|1<<NMI_bit)
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    8
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

                                else
                                  and #I_filter-(1<<\1)
                                endif
                                plp             ;set flags
                                pha             ;save to verify
                                php
                                sta I_port      ;interrupt next instruction plus outbound delay
                                endm
                        I_clr   macro  ibit     ;ibit = interrupt bit
                                lda I_port      ;turn off interrupt by bit
                                and #I_filter
                                ora #(1<<ibit)
                                sta I_port
                                endm
                                I_clr   IRQ_bit ;turn off IRQ & NMI
0409 : adfcbf          >        lda I_port      ;turn off interrupt by bit
040c : 297f            >        and #I_filter
040e : 0901            >        ora #(1<<IRQ_bit )
0410 : 8dfcbf          >        sta I_port
                        
                                I_clr   NMI_bit
0413 : adfcbf          >        lda I_port      ;turn off interrupt by bit
0416 : 297f            >        and #I_filter
0418 : 0902            >        ora #(1<<NMI_bit)
041a : 8dfcbf          >        sta I_port
                        
                              if I_ddr != 0     ;with DDR
                                lda I_ddr       ;set DDR for IRQ & NMI to enabled
                                and #I_filter
                                ora #(1<<IRQ_bit|1<<NMI_bit)
                                sta I_ddr
                              endif    
                            else                ;open collector, 0 -> I_DDR or I_port to force interrupt
                              if I_ddr != 0     ;with DDR
                        I_set   macro  ibit     ;ibit = interrupt bit
                                lda I_ddr       ;turn on interrupt by bit
                                and #I_filter
                                if ibit > 7     ;set both NMI & IRQ
                                  ora #(1<<IRQ_bit|1<<NMI_bit)
                                else
                                  ora #(1<<\1)
                                endif
                                plp             ;set flags
                                pha             ;save to verify
                                php
                                sta I_ddr       ;interrupt next instruction plus outbound delay
                                endm
                        I_clr   macro  ibit     ;ibit = interrupt bit
                                lda I_ddr       ;turn off interrupt by bit
                                and #I_filter-(1<<ibit)
                                sta I_ddr 
                                endm
                                I_clr   IRQ_bit ;turn off IRQ & NMI
                                I_clr   NMI_bit
                                lda I_port      ;precharge IRQ & NMI
                                and #I_filter-(1<<IRQ_bit|1<<NMI_bit)
                                sta I_port
                              else              ;no DDR
                        I_set   macro  ibit     ;ibit = interrupt bit
                                lda I_port      ;turn on interrupt by bit
                                and #I_filter
                                if ibit > 7     ;set both NMI & IRQ
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    9
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

                                  ora #(1<<IRQ_bit|1<<NMI_bit)
                                else
                                  ora #(1<<\1)
                                endif
                                plp             ;set flags
                                pha             ;save to verify
                                php
                                sta I_port      ;interrupt next instruction plus outbound delay
                                endm
                        I_clr   macro  ibit     ;ibit = interrupt bit
                                lda I_port      ;turn off interrupt by bit
                                and #I_filter-(1<<ibit)
                                sta I_port
                                endm
                                I_clr   IRQ_bit ;turn off IRQ & NMI
                                I_clr   NMI_bit
                              endif
                            endif
                          endif
                          
                        ; IRQ integrity test
                        ; test for clear flags seen in IRQ vector
041d : a902                     lda #2          ;set expected interrupt source IRQ
041f : 8d0302                   sta I_src
                                push_stat 0
0422 : a900            >            lda #0
0424 : 48              >            pha         ;use stack to load status
                        
                                I_set IRQ_bit
0425 : adfcbf          >        lda I_port      ;turn on interrupt by bit
                       >        if IRQ_bit > 7     ;set both NMI & IRQ
                       >          and #I_filter-(1<<IRQ_bit|1<<NMI_bit)
                       >        else
0428 : 297e            >          and #I_filter-(1<<IRQ_bit)
                       >        endif
042a : 28              >        plp             ;set flags
042b : 48              >        pha             ;save to verify
042c : 08              >        php
042d : 8dfcbf          >        sta I_port      ;interrupt next instruction plus outbound delay
                        
0430 : ea                       nop             ;allow 6 cycles for interrupt to trip
0431 : ea                       nop
0432 : ea                       nop
0433 : ad0302                   lda I_src
                                trap_ne         ;IRQ timeout
0436 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0438 : ba                       tsx
0439 : e0fd                     cpx #$ff-2      ;original accu & flags remain on stack
                                trap_ne         ;returned SP
043b : d0fe            >        bne *           ;failed not equal (non zero)
                        
043d : a502                     lda irq_f       ;flags seen in IRQ vector
                              if D_clear = 1
                                and #decmode
                                trap_ne         ;D-flag not cleared
                                lda irq_f
                                eor lst_f       ;turn off unchanged bits
                                and #m8-fai-decmode ;mask untested other flags
                                trap_ne         ;other flags (N,V,Z,C) changed
                              else
043f : 4dfe01                   eor lst_f       ;turn off unchanged bits
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page   10
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

0442 : 29cb                     and #m8-fai     ;mask untested other flags
                                trap_ne         ;other flags (N,V,Z,C,D) changed
0444 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                              endif
0446 : a2ff                     ldx #$ff        ;reset stack pointer
0448 : 9a                       txs
                        ; test all other registers
0449 : a249                     ldx #'I'
044b : a052                     ldy #'R'
044d : a902                     lda #2          ;set expected interrupt source IRQ
044f : 8d0302                   sta I_src
                                push_stat 0
0452 : a900            >            lda #0
0454 : 48              >            pha         ;use stack to load status
                        
                                I_set IRQ_bit
0455 : adfcbf          >        lda I_port      ;turn on interrupt by bit
                       >        if IRQ_bit > 7     ;set both NMI & IRQ
                       >          and #I_filter-(1<<IRQ_bit|1<<NMI_bit)
                       >        else
0458 : 297e            >          and #I_filter-(1<<IRQ_bit)
                       >        endif
045a : 28              >        plp             ;set flags
045b : 48              >        pha             ;save to verify
045c : 08              >        php
045d : 8dfcbf          >        sta I_port      ;interrupt next instruction plus outbound delay
                        
0460 : 88                       dey             ;Y count will fail, if instructions are skipped
0461 : 88                       dey
0462 : 88                       dey
0463 : 88                       dey
0464 : 08                       php             ;check processor status later
0465 : e04a                     cpx #('I'+1)    ;returned registers OK?
                                trap_ne         ;returned X
0467 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0469 : c04b                     cpy #('R'-7)
                                trap_ne         ;returned Y
046b : d0fe            >        bne *           ;failed not equal (non zero)
                        
046d : c951                     cmp #'Q'
                                trap_ne         ;returned A
046f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0471 : ba                       tsx
0472 : e0fc                     cpx #$ff-3
                                trap_ne         ;returned SP
0474 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0476 : 68                       pla             ;flags
0477 : 4dfe01                   eor lst_f
047a : 297d                     and #$ff-fnz    ;ignore flags changed by dey
                                trap_ne         ;returned flags
047c : d0fe            >        bne *           ;failed not equal (non zero)
                        
047e : a500                     lda irq_a       ;accu seen in IRQ vector
0480 : cdff01                   cmp lst_a
                                trap_ne         ;IRQ A received
0483 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0485 : a2ff                     ldx #$ff        ;reset stack pointer
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page   11
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

0487 : 9a                       txs
                        ; repeat with reversed registers
0488 : a2b6                     ldx #$ff-'I'
048a : a0ad                     ldy #$ff-'R'
048c : a902                     lda #2          ;set expected interrupt source IRQ
048e : 8d0302                   sta I_src
                                push_stat $ff-intdis
0491 : a9fb            >            lda #$ff-intdis
0493 : 48              >            pha         ;use stack to load status
                        
                                I_set IRQ_bit
0494 : adfcbf          >        lda I_port      ;turn on interrupt by bit
                       >        if IRQ_bit > 7     ;set both NMI & IRQ
                       >          and #I_filter-(1<<IRQ_bit|1<<NMI_bit)
                       >        else
0497 : 297e            >          and #I_filter-(1<<IRQ_bit)
                       >        endif
0499 : 28              >        plp             ;set flags
049a : 48              >        pha             ;save to verify
049b : 08              >        php
049c : 8dfcbf          >        sta I_port      ;interrupt next instruction plus outbound delay
                        
049f : 88                       dey             ;Y count will fail, if instructions are skipped
04a0 : 88                       dey
04a1 : 88                       dey
04a2 : 88                       dey
04a3 : 08                       php             ;check processor status later
04a4 : e0b7                     cpx #($ff-'I'+1)    ;returned registers OK?
                                trap_ne         ;returned X
04a6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
04a8 : c0a6                     cpy #($ff-'R'-7)
                                trap_ne         ;returned Y
04aa : d0fe            >        bne *           ;failed not equal (non zero)
                        
04ac : c951                     cmp #'Q'
                                trap_ne         ;returned A
04ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
04b0 : ba                       tsx
04b1 : e0fc                     cpx #$ff-3
                                trap_ne         ;returned SP
04b3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
04b5 : 68                       pla             ;flags
04b6 : 4dfe01                   eor lst_f
04b9 : 297d                     and #$ff-fnz    ;ignore flags changed by dey
                                trap_ne         ;returned flags
04bb : d0fe            >        bne *           ;failed not equal (non zero)
                        
04bd : a500                     lda irq_a       ;accu seen in IRQ vector
04bf : cdff01                   cmp lst_a
                                trap_ne         ;IRQ A received
04c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
04c4 : a2ff                     ldx #$ff        ;reset stack pointer
04c6 : 9a                       txs
                        ; retest for set flags seen in IRQ vector
04c7 : a902                     lda #2          ;set expected interrupt source IRQ
04c9 : 8d0302                   sta I_src
                                push_stat $ff-intdis
04cc : a9fb            >            lda #$ff-intdis
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page   12
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

04ce : 48              >            pha         ;use stack to load status
                        
                                I_set IRQ_bit
04cf : adfcbf          >        lda I_port      ;turn on interrupt by bit
                       >        if IRQ_bit > 7     ;set both NMI & IRQ
                       >          and #I_filter-(1<<IRQ_bit|1<<NMI_bit)
                       >        else
04d2 : 297e            >          and #I_filter-(1<<IRQ_bit)
                       >        endif
04d4 : 28              >        plp             ;set flags
04d5 : 48              >        pha             ;save to verify
04d6 : 08              >        php
04d7 : 8dfcbf          >        sta I_port      ;interrupt next instruction plus outbound delay
                        
04da : ea                       nop             ;allow 6 cycles for interrupt to trip
04db : ea                       nop
04dc : ea                       nop
04dd : ad0302                   lda I_src
                                trap_ne         ;IRQ timeout
04e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
04e2 : ba                       tsx
04e3 : e0fd                     cpx #$ff-2      ;original accu & flags remain on stack
                                trap_ne         ;returned SP
04e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
04e7 : a502                     lda irq_f       ;flags seen in IRQ vector
                              if D_clear = 1
                                and #decmode
                                trap_ne         ;D-flag not cleared
                                lda irq_f
                                eor lst_f       ;turn off unchanged bits
                                and #m8-fai-decmode ;mask untested other flags
                                trap_ne         ;other flags (N,V,Z,C) changed
                              else
04e9 : 4dfe01                   eor lst_f       ;turn off unchanged bits
04ec : 29cb                     and #m8-fai     ;mask untested other flags
                                trap_ne         ;other flags (N,V,Z,C,D) changed
04ee : d0fe            >        bne *           ;failed not equal (non zero)
                        
                              endif
04f0 : a2ff                     ldx #$ff        ;reset stack pointer
04f2 : 9a                       txs
                        
                        ; BRK integrity test
                        ; test for clear flags seen in IRQ vector
04f3 : a901                     lda #1          ;set expected interrupt source BRK
04f5 : 8d0302                   sta I_src
                                set_stat 0
04f8 : a900            >            lda #0
04fa : 48              >            pha         ;use stack to load status
04fb : 28              >            plp
                        
04fc : 48                       pha             ;save entry registers
04fd : 08                       php
04fe : 00                       brk
04ff : ea                       nop             ;should not be executed
0500 : ea                       nop             ;allow 6 cycles for interrupt to trip
0501 : ea                       nop
0502 : ea                       nop
0503 : ad0302                   lda I_src
                                trap_ne         ;IRQ timeout
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page   13
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

0506 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0508 : ba                       tsx
0509 : e0fd                     cpx #$ff-2      ;original accu & flags remain on stack
                                trap_ne         ;returned SP
050b : d0fe            >        bne *           ;failed not equal (non zero)
                        
050d : a502                     lda irq_f       ;flags seen in IRQ vector
                              if D_clear = 1
                                and #decmode
                                trap_ne         ;D-flag not cleared
                                lda irq_f
                                eor lst_f       ;turn off unchanged bits
                                and #m8-fai-decmode ;mask untested other flags
                                trap_ne         ;other flags (N,V,Z,C) changed
                              else
050f : 4dfe01                   eor lst_f       ;turn off unchanged bits
0512 : 29cb                     and #m8-fai     ;mask untested other flags
                                trap_ne         ;other flags (N,V,Z,C,D) changed
0514 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                              endif
0516 : a2ff                     ldx #$ff        ;reset stack pointer
0518 : 9a                       txs
                        ; test all other registers
0519 : a242                     ldx #'B'
051b : a052                     ldy #'R'
051d : a901                     lda #1          ;set expected interrupt source BRK
051f : 8d0302                   sta I_src
                                set_stat 0
0522 : a900            >            lda #0
0524 : 48              >            pha         ;use stack to load status
0525 : 28              >            plp
                        
0526 : 48                       pha             ;save entry
0527 : 08                       php
0528 : 00                       brk
0529 : 88                       dey             ;should not be executed
052a : 88                       dey             ;Y count will fail, if return address is wrong
052b : 88                       dey
052c : 88                       dey
052d : 88                       dey
052e : 08                       php             ;check processor status later
052f : e043                     cpx #('B'+1)    ;returned registers OK?
                                trap_ne         ;returned X
0531 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0533 : c04b                     cpy #('R'-7)
                                trap_ne         ;returned Y
0535 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0537 : c94b                     cmp #'K'
                                trap_ne         ;returned A
0539 : d0fe            >        bne *           ;failed not equal (non zero)
                        
053b : ba                       tsx
053c : e0fc                     cpx #$ff-3
                                trap_ne         ;returned SP
053e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0540 : 68                       pla             ;flags
0541 : 4dfe01                   eor lst_f
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page   14
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

0544 : 297d                     and #$ff-fnz    ;ignore flags changed by dey
                                trap_ne         ;returned flags
0546 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0548 : a500                     lda irq_a       ;accu seen in IRQ vector
054a : cdff01                   cmp lst_a
                                trap_ne         ;IRQ A received
054d : d0fe            >        bne *           ;failed not equal (non zero)
                        
054f : a2ff                     ldx #$ff        ;reset stack pointer
0551 : 9a                       txs
                        ; repeat with reversed registers
0552 : a2bd                     ldx #$ff-'B'
0554 : a0ad                     ldy #$ff-'R'
0556 : a901                     lda #1          ;set expected interrupt source BRK
0558 : 8d0302                   sta I_src
                                set_stat $ff
055b : a9ff            >            lda #$ff
055d : 48              >            pha         ;use stack to load status
055e : 28              >            plp
                        
055f : 48                       pha             ;save entry registers
0560 : 08                       php
0561 : 00                       brk
0562 : 88                       dey             ;should not be executed
0563 : 88                       dey             ;Y count will fail, if return address is wrong
0564 : 88                       dey
0565 : 88                       dey
0566 : 88                       dey
0567 : 08                       php             ;check processor status later
0568 : e0be                     cpx #($ff-'B'+1)    ;returned registers OK?
                                trap_ne         ;returned X
056a : d0fe            >        bne *           ;failed not equal (non zero)
                        
056c : c0a6                     cpy #($ff-'R'-7)
                                trap_ne         ;returned Y
056e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0570 : c94b                     cmp #'K'
                                trap_ne         ;returned A
0572 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0574 : ba                       tsx
0575 : e0fc                     cpx #$ff-3
                                trap_ne         ;returned SP
0577 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0579 : 68                       pla             ;flags
057a : 4dfe01                   eor lst_f
057d : 297d                     and #$ff-fnz    ;ignore flags changed by dey
                                trap_ne         ;returned flags
057f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0581 : a500                     lda irq_a       ;accu seen in IRQ vector
0583 : cdff01                   cmp lst_a
                                trap_ne         ;IRQ A received
0586 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0588 : a2ff                     ldx #$ff        ;reset stack pointer
058a : 9a                       txs
                        ; retest for set flags seen in IRQ vector
058b : a901                     lda #1          ;set expected interrupt source BRK
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page   15
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

058d : 8d0302                   sta I_src
                                set_stat $ff
0590 : a9ff            >            lda #$ff
0592 : 48              >            pha         ;use stack to load status
0593 : 28              >            plp
                        
0594 : 48                       pha             ;save entry registers
0595 : 08                       php
0596 : 00                       brk
0597 : ea                       nop             ;should not be executed
0598 : ea                       nop             ;allow 6 cycles for interrupt to trip
0599 : ea                       nop
059a : ea                       nop
059b : ad0302                   lda I_src
                                trap_ne         ;IRQ timeout
059e : d0fe            >        bne *           ;failed not equal (non zero)
                        
05a0 : ba                       tsx
05a1 : e0fd                     cpx #$ff-2      ;original accu & flags remain on stack
                                trap_ne         ;returned SP
05a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05a5 : a502                     lda irq_f       ;flags seen in IRQ vector
                              if D_clear = 1
                                and #decmode
                                trap_ne         ;D-flag not cleared
                                lda irq_f
                                eor lst_f       ;turn off unchanged bits
                                and #m8-fai-decmode ;mask untested other flags
                                trap_ne         ;other flags (N,V,Z,C) changed
                              else
05a7 : 4dfe01                   eor lst_f       ;turn off unchanged bits
05aa : 29cb                     and #m8-fai     ;mask untested other flags
                                trap_ne         ;other flags (N,V,Z,C,D) changed
05ac : d0fe            >        bne *           ;failed not equal (non zero)
                        
                              endif
05ae : a2ff                     ldx #$ff        ;reset stack pointer
05b0 : 9a                       txs
                        
                            if NMI_bit < 0
                        ; test IRQ with interrupts disabled
                                ldx #0
                                lda #0
                                sta I_src
                                push_stat intdis        
                                I_set IRQ_bit   ;IRQ pending
                                inx
                                inx
                                inx
                                ldx #0
                                lda #2          ;now re-enable IRQ
                                sta I_src
                                cli
                                inx
                                inx
                                inx
                                lda I_src       ;test IRQ done?
                                trap_ne
                                ldx #$ff        ;purge stack
                                txs
                        
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page   16
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

                                ldx #0          ;now overlap IRQ & BRK
                                lda #3
                                sta I_src
                                lda #$ff        ;measure timing
                                sta nmi_count
                                sta irq_count
                                sta brk_count
                                push_stat 0        
                                I_set IRQ_bit   ;trigger IRQ
                            else
                        ; NMI integrity test
                        ; test for clear flags seen in NMI vector
05b1 : a904                     lda #4          ;set expected interrupt source NMI
05b3 : 8d0302                   sta I_src
                                push_stat 0
05b6 : a900            >            lda #0
05b8 : 48              >            pha         ;use stack to load status
                        
                                I_set NMI_bit
05b9 : adfcbf          >        lda I_port      ;turn on interrupt by bit
                       >        if NMI_bit > 7     ;set both NMI & IRQ
                       >          and #I_filter-(1<<IRQ_bit|1<<NMI_bit)
                       >        else
05bc : 297d            >          and #I_filter-(1<<NMI_bit)
                       >        endif
05be : 28              >        plp             ;set flags
05bf : 48              >        pha             ;save to verify
05c0 : 08              >        php
05c1 : 8dfcbf          >        sta I_port      ;interrupt next instruction plus outbound delay
                        
05c4 : ea                       nop             ;allow 6 cycles for interrupt to trip
05c5 : ea                       nop
05c6 : ea                       nop
05c7 : ad0302                   lda I_src
                                trap_ne         ;NMI timeout
05ca : d0fe            >        bne *           ;failed not equal (non zero)
                        
05cc : ba                       tsx
05cd : e0fd                     cpx #$ff-2      ;original accu & flags remain on stack
                                trap_ne         ;returned SP
05cf : d0fe            >        bne *           ;failed not equal (non zero)
                        
05d1 : a505                     lda nmi_f       ;flags seen in NMI vector
                              if D_clear = 1
                                and #decmode
                                trap_ne         ;D-flag not cleared
                                lda nmi_f
                                eor lst_f       ;turn off unchanged bits
                                and #m8-fai-decmode ;mask untested other flags
                                trap_ne         ;other flags (N,V,Z,C) changed
                              else
05d3 : 4dfe01                   eor lst_f       ;turn off unchanged bits
05d6 : 29cb                     and #m8-fai     ;mask untested other flags
                                trap_ne         ;other flags (N,V,Z,C,D) changed
05d8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                              endif
05da : a2ff                     ldx #$ff        ;reset stack pointer
05dc : 9a                       txs
                        ; test all other registers
05dd : a24e                     ldx #'N'
05df : a04d                     ldy #'M'
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page   17
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

05e1 : a904                     lda #4          ;set expected interrupt source NMI
05e3 : 8d0302                   sta I_src
                                push_stat 0
05e6 : a900            >            lda #0
05e8 : 48              >            pha         ;use stack to load status
                        
                                I_set NMI_bit
05e9 : adfcbf          >        lda I_port      ;turn on interrupt by bit
                       >        if NMI_bit > 7     ;set both NMI & IRQ
                       >          and #I_filter-(1<<IRQ_bit|1<<NMI_bit)
                       >        else
05ec : 297d            >          and #I_filter-(1<<NMI_bit)
                       >        endif
05ee : 28              >        plp             ;set flags
05ef : 48              >        pha             ;save to verify
05f0 : 08              >        php
05f1 : 8dfcbf          >        sta I_port      ;interrupt next instruction plus outbound delay
                        
05f4 : 88                       dey             ;Y count will fail, if instructions are skipped
05f5 : 88                       dey
05f6 : 88                       dey
05f7 : 88                       dey
05f8 : 08                       php             ;check processor status later
05f9 : e04f                     cpx #('N'+1)    ;returned registers OK?
                                trap_ne         ;returned X
05fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
05fd : c046                     cpy #('M'-7)
                                trap_ne         ;returned Y
05ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
0601 : c949                     cmp #'I'
                                trap_ne         ;returned A
0603 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0605 : ba                       tsx
0606 : e0fc                     cpx #$ff-3
                                trap_ne         ;returned SP
0608 : d0fe            >        bne *           ;failed not equal (non zero)
                        
060a : 68                       pla             ;flags
060b : 4dfe01                   eor lst_f
060e : 297d                     and #$ff-fnz    ;ignore flags changed by dey
                                trap_ne         ;returned flags
0610 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0612 : a503                     lda nmi_a       ;accu seen in NMI vector
0614 : cdff01                   cmp lst_a
                                trap_ne         ;NMI A received
0617 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0619 : a2ff                     ldx #$ff        ;reset stack pointer
061b : 9a                       txs
                        ; repeat with reversed registers
061c : a2b1                     ldx #$ff-'N'
061e : a0b2                     ldy #$ff-'M'
0620 : a904                     lda #4          ;set expected interrupt source NMI
0622 : 8d0302                   sta I_src
                                push_stat $ff-intdis
0625 : a9fb            >            lda #$ff-intdis
0627 : 48              >            pha         ;use stack to load status
                        
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page   18
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

                                I_set NMI_bit
0628 : adfcbf          >        lda I_port      ;turn on interrupt by bit
                       >        if NMI_bit > 7     ;set both NMI & IRQ
                       >          and #I_filter-(1<<IRQ_bit|1<<NMI_bit)
                       >        else
062b : 297d            >          and #I_filter-(1<<NMI_bit)
                       >        endif
062d : 28              >        plp             ;set flags
062e : 48              >        pha             ;save to verify
062f : 08              >        php
0630 : 8dfcbf          >        sta I_port      ;interrupt next instruction plus outbound delay
                        
0633 : 88                       dey             ;Y count will fail, if instructions are skipped
0634 : 88                       dey
0635 : 88                       dey
0636 : 88                       dey
0637 : 08                       php             ;check processor status later
0638 : e0b2                     cpx #($ff-'N'+1)    ;returned registers OK?
                                trap_ne         ;returned X
063a : d0fe            >        bne *           ;failed not equal (non zero)
                        
063c : c0ab                     cpy #($ff-'M'-7)
                                trap_ne         ;returned Y
063e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0640 : c949                     cmp #'I'
                                trap_ne         ;returned A
0642 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0644 : ba                       tsx
0645 : e0fc                     cpx #$ff-3
                                trap_ne         ;returned SP
0647 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0649 : 68                       pla             ;flags
064a : 4dfe01                   eor lst_f
064d : 297d                     and #$ff-fnz    ;ignore flags changed by dey
                                trap_ne         ;returned flags
064f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0651 : a503                     lda nmi_a       ;accu seen in NMI vector
0653 : cdff01                   cmp lst_a
                                trap_ne         ;NMI A received
0656 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0658 : a2ff                     ldx #$ff        ;reset stack pointer
065a : 9a                       txs
                        ; retest for set flags seen in NMI vector
065b : a904                     lda #4          ;set expected interrupt source NMI
065d : 8d0302                   sta I_src
                                push_stat $ff-intdis
0660 : a9fb            >            lda #$ff-intdis
0662 : 48              >            pha         ;use stack to load status
                        
                                I_set NMI_bit
0663 : adfcbf          >        lda I_port      ;turn on interrupt by bit
                       >        if NMI_bit > 7     ;set both NMI & IRQ
                       >          and #I_filter-(1<<IRQ_bit|1<<NMI_bit)
                       >        else
0666 : 297d            >          and #I_filter-(1<<NMI_bit)
                       >        endif
0668 : 28              >        plp             ;set flags
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page   19
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

0669 : 48              >        pha             ;save to verify
066a : 08              >        php
066b : 8dfcbf          >        sta I_port      ;interrupt next instruction plus outbound delay
                        
066e : ea                       nop             ;allow 6 cycles for interrupt to trip
066f : ea                       nop
0670 : ea                       nop
0671 : ad0302                   lda I_src
                                trap_ne         ;NMI timeout
0674 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0676 : ba                       tsx
0677 : e0fd                     cpx #$ff-2      ;original accu & flags remain on stack
                                trap_ne         ;returned SP
0679 : d0fe            >        bne *           ;failed not equal (non zero)
                        
067b : a505                     lda nmi_f       ;flags seen in NMI vector
                              if D_clear = 1
                                and #decmode
                                trap_ne         ;D-flag not cleared
                                lda nmi_f
                                eor lst_f       ;turn off unchanged bits
                                and #m8-fai-decmode ;mask untested other flags
                                trap_ne         ;other flags (N,V,Z,C) changed
                              else
067d : 4dfe01                   eor lst_f       ;turn off unchanged bits
0680 : 29cb                     and #m8-fai     ;mask untested other flags
                                trap_ne         ;other flags (N,V,Z,C,D) changed
0682 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                              endif
0684 : a2ff                     ldx #$ff        ;reset stack pointer
0686 : 9a                       txs
                        
                        ; test IRQ & NMI with interrupts disabled
0687 : a200                     ldx #0
0689 : a904                     lda #4          ;set expected interrupt NMI only
068b : 8d0302                   sta I_src
                                push_stat intdis        
068e : a904            >            lda #intdis        
0690 : 48              >            pha         ;use stack to load status
                        
                                I_set 8         ;both interrupts pending
0691 : adfcbf          >        lda I_port      ;turn on interrupt by bit
                       >        if 8          > 7     ;set both NMI & IRQ
0694 : 297c            >          and #I_filter-(1<<IRQ_bit|1<<NMI_bit)
                       >        else
                       >          and #I_filter-(1<<8         )
                       >        endif
0696 : 28              >        plp             ;set flags
0697 : 48              >        pha             ;save to verify
0698 : 08              >        php
0699 : 8dfcbf          >        sta I_port      ;interrupt next instruction plus outbound delay
                        
069c : e8                       inx
069d : e8                       inx
069e : e8                       inx
069f : ad0302                   lda I_src       ;test NMI done?
                                trap_ne
06a2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
06a4 : a200                     ldx #0
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page   20
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

06a6 : a902                     lda #2          ;now re-enable IRQ
06a8 : 8d0302                   sta I_src
06ab : 58                       cli
06ac : e8                       inx
06ad : e8                       inx
06ae : e8                       inx
06af : ad0302                   lda I_src       ;test IRQ done?
                                trap_ne
06b2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
06b4 : a2ff                     ldx #$ff        ;purge stack
06b6 : 9a                       txs
                        
                        ;test overlapping NMI, IRQ & BRK
06b7 : a200                     ldx #0
06b9 : a907                     lda #7
06bb : 8d0302                   sta I_src
06be : a9ff                     lda #$ff        ;measure timing
06c0 : 8d0002                   sta nmi_count
06c3 : 8d0102                   sta irq_count
06c6 : 8d0202                   sta brk_count
                                push_stat 0
06c9 : a900            >            lda #0
06cb : 48              >            pha         ;use stack to load status
                        
                                I_set 8         ;trigger NMI + IRQ
06cc : adfcbf          >        lda I_port      ;turn on interrupt by bit
                       >        if 8          > 7     ;set both NMI & IRQ
06cf : 297c            >          and #I_filter-(1<<IRQ_bit|1<<NMI_bit)
                       >        else
                       >          and #I_filter-(1<<8         )
                       >        endif
06d1 : 28              >        plp             ;set flags
06d2 : 48              >        pha             ;save to verify
06d3 : 08              >        php
06d4 : 8dfcbf          >        sta I_port      ;interrupt next instruction plus outbound delay
                        
                            endif
06d7 : 00                       brk
06d8 : e8                       inx
06d9 : e8                       inx
06da : e8                       inx
06db : e8                       inx
06dc : e8                       inx
06dd : e8                       inx
06de : e8                       inx
06df : e8                       inx
06e0 : ad0302                   lda I_src       ;test all done?
                        ;may fail due to a bug on a real NMOS 6502 - NMI could mask BRK
                                trap_ne         ;lost an interrupt
06e3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                        ; S U C C E S S ************************************************       
                        ; -------------       
                                success         ;if you get here everything went well
06e5 : 4ce506          >        jmp *           ;test passed, no errors
                        
                        ; -------------       
                        ; S U C C E S S ************************************************       
                        ; check data_segment +0 to +2 for sequence of concurrent interrupts
                        ; e.g. 0x200 = NMI, 0x201 = IRQ, 0x202 = BRK, lower values = earlier
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page   21
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

06e8 : 4c0004                   jmp start       ;run again      
                        
                        ; manual tests for the WAI opcode of the 65c02
                        
                        wai     macro   
                                db  $cb         ;WAI opcode
                                endm
                                
                        ; requires single step operation, report = 0
                        ;   set PC to the 1st instruction of the test
                        ;   step to the WAI opcode, then manually tie the IRQ input low
                        ;   continue to step until you see the PC advance, then remove IRQ
                        ;   allow the routine to complete.
                        
                        ; WAI with interrupts disabled
06eb : a2ff                     ldx #$ff
06ed : 9a                       txs
06ee : a003                     ldy #3
06f0 : a900                     lda #0          ;IRQ not expected
06f2 : 8d0302                   sta I_src
                                set_stat intdis
06f5 : a904            >            lda #intdis
06f7 : 48              >            pha         ;use stack to load status
06f8 : 28              >            plp
                        
                                wai
06f9 : cb              >        db  $cb         ;WAI opcode
                        
06fa : 88                       dey
06fb : 88                       dey
06fc : 88                       dey
                                trap_ne         ;skipped opcodes!
06fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                success
06ff : 4cff06          >        jmp *           ;test passed, no errors
                        
                                
                        ; WAI with interrupts enabled
0702 : a2ff                     ldx #$ff
0704 : 9a                       txs
0705 : a007                     ldy #7
0707 : a902                     lda #2          ;IRQ expected
0709 : 8d0302                   sta I_src
                                set_stat 0
070c : a900            >            lda #0
070e : 48              >            pha         ;use stack to load status
070f : 28              >            plp
                        
                                wai
0710 : cb              >        db  $cb         ;WAI opcode
                        
0711 : 88                       dey
0712 : 88                       dey
0713 : 88                       dey
0714 : ad0302                   lda I_src
                                trap_ne         ;IRQ vector not called
0717 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0719 : 88                       dey
                                trap_ne         ;skipped opcodes!
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page   22
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

071a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                success
071c : 4c1c07          >        jmp *           ;test passed, no errors
                        
                                
                        ; manual test for the STP opcode of the 65c02
                        
                        stp     macro   
                                db  $db         ;STP opcode
                                endm
                                
                        ; set PC to the 1st instruction of the test, then run
071f : ea                       nop
0720 : ea                       nop
                                stp             ;expected end of operation
0721 : db              >        db  $db         ;STP opcode
                        
0722 : ea                       nop
0723 : ea                       nop
                                trap            ;overran STP
0724 : 4c2407          >        jmp *           ;failed anyway
                        
                        
                        ;end of manual tests
                        
                        ;---------------------------------------------------------------------------
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - IRQ, NMI, BRK test target
0727 : 88                       dey
0728 : 88                       dey
0729 :                  nmi_trap
                            if NMI_bit < 0
                                dey
                                dey
                                dey
                                trap            ;unexpected NMI
                            else
0729 : 08                       php             ;either SP or Y count will fail, if we do not hit
072a : 88                       dey
072b : 88                       dey
072c : 88                       dey
072d : 8503                     sta nmi_a       ;save regsters during NMI
072f : 8604                     stx nmi_x
0731 : 68                       pla
0732 : 48                       pha
0733 : 8505                     sta nmi_f
0735 : ad0302                   lda I_src       ;NMI expected?
0738 : 2904                     and #4   
                                trap_eq         ;unexpexted NMI - check stack for conditions
073a : f0fe            >        beq *           ;failed equal (zero)
                        
073c : 68                       pla             ;test I-flag was set
073d : 48                       pha
073e : 2904                     and #intdis
                                trap_eq         ;I-flag not set
0740 : f0fe            >        beq *           ;failed equal (zero)
                        
0742 : 68                       pla             ;return with other flags reversed
0743 : 49c3                     eor #m8-fai-decmode
0745 : 48                       pha
0746 : ba                       tsx        
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page   23
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

0747 : bd0201                   lda $102,x     ;test break on stack
074a : 2910                     and #break
                                trap_ne         ;unexpected B-flag! - this may fail on a real 6502
074c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                                ;due to a hardware bug on concurrent BRK & NMI
074e : ad0302                   lda I_src       ;mark expected NMI has occured
0751 : 29fb                     and #$ff-4
0753 : 8d0302                   sta I_src
                                I_clr   NMI_bit   
0756 : adfcbf          >        lda I_port      ;turn off interrupt by bit
0759 : 297f            >        and #I_filter
075b : 0902            >        ora #(1<<NMI_bit   )
075d : 8dfcbf          >        sta I_port
                        
0760 : a604                     ldx nmi_x
0762 : e8                       inx
0763 : 8e0002                   stx nmi_count
0766 : a949                     lda #'I'        ;mark (NM)I
0768 : 28                       plp             ;should be reversed by rti
0769 : 40                       rti
                            endif
                        
076a :                  res_trap
                                trap            ;unexpected RESET
076a : 4c6a07          >        jmp *           ;failed anyway
                        
                                
076d : 88                       dey
076e : 88                       dey
076f :                  irq_trap                ;BRK & IRQ test
076f : 08                       php             ;either SP or Y count will fail, if we do not hit
0770 : 88                       dey
0771 : 88                       dey
0772 : 88                       dey
0773 : 8500                     sta irq_a       ;save registers during IRQ/BRK
0775 : 8601                     stx irq_x
0777 : 68                       pla
0778 : 48                       pha
0779 : 8502                     sta irq_f
077b : ad0302                   lda I_src       ;IRQ expected?
077e : 2903                     and #3   
                                trap_eq         ;unexpexted IRQ/BRK - check stack for conditions
0780 : f0fe            >        beq *           ;failed equal (zero)
                        
0782 : 68                       pla             ;test I-flag was set
0783 : 48                       pha
0784 : 2904                     and #intdis
                                trap_eq         ;I-flag not set
0786 : f0fe            >        beq *           ;failed equal (zero)
                        
0788 : 68                       pla             ;return with other flags reversed
0789 : 49c3                     eor #m8-fai-decmode
078b : 48                       pha        
078c : ba                       tsx
078d : bd0201                   lda $102,x      ;test break on stack
0790 : 2910                     and #break
0792 : d023                     bne brk_trap
                                
0794 : ad0302                   lda I_src       ;IRQ expected?
0797 : 2902                     and #2   
                                trap_eq         ;unexpexted IRQ - check stack for conditions
AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page   24
---------------------------------------------------- 6502_interrupt_test.a65 -----------------------------------------------------

0799 : f0fe            >        beq *           ;failed equal (zero)
                        
079b : ad0302                   lda I_src       ;mark expected IRQ has occured
079e : 29fd                     and #$ff-2
07a0 : 8d0302                   sta I_src
                                I_clr   IRQ_bit   
07a3 : adfcbf          >        lda I_port      ;turn off interrupt by bit
07a6 : 297f            >        and #I_filter
07a8 : 0901            >        ora #(1<<IRQ_bit   )
07aa : 8dfcbf          >        sta I_port
                        
07ad : a601                     ldx irq_x
07af : e8                       inx
07b0 : 8e0102                   stx irq_count
07b3 : a951                     lda #'Q'        ;mark (IR)Q
07b5 : 28                       plp             ;should be reversed by rti
07b6 : 40                       rti
                                
07b7 :                  brk_trap
07b7 : ad0302                   lda I_src       ;break expected?
07ba : 2901                     and #1
                                trap_eq         ;unexpected BRK - check stack for conditions
07bc : f0fe            >        beq *           ;failed equal (zero)
                        
07be : ad0302                   lda I_src       ;mark expected BRK has occured
07c1 : 29fe                     and #$ff-1
07c3 : 8d0302                   sta I_src
07c6 : a601                     ldx irq_x
07c8 : e8                       inx
07c9 : 8e0202                   stx brk_count   
07cc : a500                     lda irq_a
07ce : a94b                     lda #'K'        ;mark (BR)K
07d0 : 28                       plp             ;should be reversed by rti
07d1 : 40                       rti
                                
                            if report = 1
                        rep_int = 1
                                include "report.i65"
                            endif
                        
                                
                        ;system vectors
                            if (load_data_direct = 1)
fffa =                          org $fffa
fffa : 2907                     dw  nmi_trap
fffc : 6a07                     dw  res_trap
fffe : 6f07                     dw  irq_trap
                            else
                        vec_init
                        vec_bss equ $fffa
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                            endif
                            
fffa =                          end start
                                
                            
No errors in pass 2.
Wrote binary from address $0000 through $ffff.
Total size 65536 bytes.
Program start address is at $0400 (1024).
